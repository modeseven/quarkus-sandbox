package org.acme;

import io.quarkus.test.junit.QuarkusTest;
import io.quarkus.test.junit.TestProfile;
import jakarta.inject.Inject;
import org.acme.cache.CacheService;
import org.acme.cache.qualifiers.DefaultCacheImpl;
import org.acme.qualifiers.CachedTransactionRunnerQualifier;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.util.*;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Simple test for CachedTransactionRunner that tests the caching flow with in-memory cache.
 * This test manually populates the cache and verifies that fields are properly hydrated.
 */
@QuarkusTest
@TestProfile(CachedTransactionRunnerSimpleTest.TestProfile.class)
public class CachedTransactionRunnerSimpleTest {

    @Inject
    @CachedTransactionRunnerQualifier
    CachedTransactionRunner cachedTransactionRunner;

    @Inject
    @DefaultCacheImpl
    CacheService cacheService;

    @BeforeEach
    public void setUp() {
        // Clear cache before each test
        cacheService.clearAll();
    }

    @Test
    public void testCacheHitWithFieldHydration() {
        // === STEP 1: Manually populate cache with TF fields ===
        
        Map<String, String> cachedTfData = new HashMap<>();
        // Add 10 tablefacility fields to cache
        for (int i = 1; i <= 10; i++) {
            cachedTfData.put("tablefacility_" + i, "cached_data_" + i);
        }
        // Add some other cached fields
        cachedTfData.put("status", "processed");
        cachedTfData.put("facility_id", "facility_001");
        cachedTfData.put("amount", "100.50");
        cachedTfData.put("currency", "USD");
        
        // Serialize and store in cache
        String cacheKey = "test-cache-key-123";
        String serializedData = serializeMap(cachedTfData);
        cacheService.put(cacheKey, serializedData, 3600);
        
        // === STEP 2: First call with cache key (should hydrate fields) ===
        
        Map<String, String> firstCallInput = new HashMap<>();
        firstCallInput.put("user_id", "user123");
        firstCallInput.put("amount", "200.00"); // This should be overridden by cached data
        firstCallInput.put("currency", "EUR"); // This should be overridden by cached data
        firstCallInput.put("operation", "transfer");
        firstCallInput.put("tf_cache_key", cacheKey); // Use the cache key
        
        // Process first transaction
        CiclopsResponse firstResponse = cachedTransactionRunner.processTransaction(firstCallInput, "test-trx-001");
        
        // Verify first response
        assertNotNull(firstResponse, "First response should not be null");
        assertNotNull(firstResponse.getFields(), "First response fields should not be null");
        
        // Debug: Print all fields in the response
        System.out.println("First response fields: " + firstResponse.getFields().keySet());
        for (Map.Entry<String, List<String>> entry : firstResponse.getFields().entrySet()) {
            System.out.println("  " + entry.getKey() + " = " + entry.getValue());
        }
        
        // Verify that cached fields are hydrated (should override original values)
        assertEquals("100.50", firstResponse.getFields().get("amount").get(0), 
                    "Amount should be hydrated from cache");
        assertEquals("USD", firstResponse.getFields().get("currency").get(0), 
                    "Currency should be hydrated from cache");
        assertEquals("processed", firstResponse.getFields().get("status").get(0), 
                    "Status should be hydrated from cache");
        assertEquals("facility_001", firstResponse.getFields().get("facility_id").get(0), 
                    "Facility ID should be hydrated from cache");
        
        // Verify TF fields are NOT in the response (they should be removed and cached)
        // The TF fields are hydrated into the input to TestTransactionRunner, but then
        // ResponseCacheServiceImpl removes them from the response and caches them
        for (int i = 1; i <= 10; i++) {
            assertNull(firstResponse.getFields().get("tablefacility_" + i), 
                      "Tablefacility field " + i + " should be removed from response after caching");
        }
        
        // Verify original fields are preserved
        assertEquals("user123", firstResponse.getFields().get("user_id").get(0), 
                    "Original field 'user_id' should be preserved");
        assertEquals("transfer", firstResponse.getFields().get("operation").get(0), 
                    "Original field 'operation' should be preserved");
        
        // Verify cache key is present (should be the NEW cache key generated by ResponseCacheServiceImpl)
        assertNotNull(firstResponse.getFields().get("tf_cache_key"), 
                     "Response should contain a cache key");
        String newCacheKey = firstResponse.getFields().get("tf_cache_key").get(0);
        assertNotNull(newCacheKey, "New cache key should not be null");
        assertTrue(newCacheKey.startsWith("tf_cache_"), "New cache key should start with tf_cache_");
        
        // === STEP 3: Second call with new cache key (should get same hydrated data) ===
        
        Map<String, String> secondCallInput = new HashMap<>();
        secondCallInput.put("user_id", "user456");
        secondCallInput.put("amount", "300.00"); // This should be overridden by cached data
        secondCallInput.put("currency", "GBP"); // This should be overridden by cached data
        secondCallInput.put("operation", "withdrawal");
        secondCallInput.put("tf_cache_key", newCacheKey); // Use the new cache key from first call
        
        // Process second transaction
        CiclopsResponse secondResponse = cachedTransactionRunner.processTransaction(secondCallInput, "test-trx-002");
        
        // Verify second response
        assertNotNull(secondResponse, "Second response should not be null");
        assertNotNull(secondResponse.getFields(), "Second response fields should not be null");
        
        // Debug: Print all fields in the second response
        System.out.println("Second response fields: " + secondResponse.getFields().keySet());
        for (Map.Entry<String, List<String>> entry : secondResponse.getFields().entrySet()) {
            System.out.println("  " + entry.getKey() + " = " + entry.getValue());
        }
        
        // Verify that cached fields are hydrated again (same cached data)
        assertEquals("100.50", secondResponse.getFields().get("amount").get(0), 
                    "Amount should be hydrated from cache again");
        assertEquals("USD", secondResponse.getFields().get("currency").get(0), 
                    "Currency should be hydrated from cache again");
        assertEquals("processed", secondResponse.getFields().get("status").get(0), 
                    "Status should be hydrated from cache again");
        assertEquals("facility_001", secondResponse.getFields().get("facility_id").get(0), 
                    "Facility ID should be hydrated from cache again");
        
        // Verify TF fields are NOT in the response again (they should be removed and cached)
        for (int i = 1; i <= 10; i++) {
            assertNull(secondResponse.getFields().get("tablefacility_" + i), 
                      "Tablefacility field " + i + " should be removed from response after caching again");
        }
        
        // Verify new original fields are preserved
        assertEquals("user456", secondResponse.getFields().get("user_id").get(0), 
                    "New original field 'user_id' should be preserved");
        assertEquals("withdrawal", secondResponse.getFields().get("operation").get(0), 
                    "New original field 'operation' should be preserved");
        
        // Verify cache key is present (should be a NEW cache key generated by ResponseCacheServiceImpl)
        assertNotNull(secondResponse.getFields().get("tf_cache_key"), 
                     "Second response should contain a cache key");
        String secondNewCacheKey = secondResponse.getFields().get("tf_cache_key").get(0);
        assertNotNull(secondNewCacheKey, "Second new cache key should not be null");
        assertTrue(secondNewCacheKey.startsWith("tf_cache_"), "Second new cache key should start with tf_cache_");
        
        // === VERIFY CACHE BEHAVIOR ===
        
        // Verify that the original cache key still exists in the cache
        String originalCachedData = cacheService.get(cacheKey);
        assertNotNull(originalCachedData, "Original cached data should still exist in cache");
        
        // Verify that the original cached data contains the TF fields
        assertTrue(originalCachedData.contains("tablefacility_1"), "Original cached data should contain tablefacility_1");
        assertTrue(originalCachedData.contains("cached_data_1"), "Original cached data should contain cached_data_1");
        assertTrue(originalCachedData.contains("tablefacility_10"), "Original cached data should contain tablefacility_10");
        assertTrue(originalCachedData.contains("cached_data_10"), "Original cached data should contain cached_data_10");
        
        // Verify that the new cache key exists in the cache (from first call)
        String firstNewCachedData = cacheService.get(newCacheKey);
        assertNotNull(firstNewCachedData, "First new cached data should exist in cache");
        
        // Verify that the second new cache key exists in the cache (from second call)
        String secondNewCachedData = cacheService.get(secondNewCacheKey);
        assertNotNull(secondNewCachedData, "Second new cached data should exist in cache");
        
        // Verify total number of fields in responses
        // First response: user_id, operation, tf_cache_key + all hydrated fields (status, facility_id, amount, currency)
        int firstExpectedFieldCount = 3 + 4; // original + hydrated fields
        assertEquals(firstExpectedFieldCount, firstResponse.getFields().size(),
                    "First response should have " + firstExpectedFieldCount + " fields");
        
        // Second response: user_id, operation, tf_cache_key + all hydrated fields (status, facility_id, amount, currency)
        int secondExpectedFieldCount = 3 + 4; // original + hydrated fields
        assertEquals(secondExpectedFieldCount, secondResponse.getFields().size(),
                    "Second response should have " + secondExpectedFieldCount + " fields");
    }

    @Test
    public void testCacheMissScenario() {
        // Test with a non-existent cache key
        Map<String, String> inputFields = new HashMap<>();
        inputFields.put("user_id", "user999");
        inputFields.put("amount", "50.00");
        inputFields.put("tf_cache_key", "non-existent-cache-key");
        
        CiclopsResponse response = cachedTransactionRunner.processTransaction(inputFields, "test-trx-999");
        
        // Verify response is not null
        assertNotNull(response, "Response should not be null");
        assertNotNull(response.getFields(), "Response fields should not be null");
        
        // Verify original fields are preserved
        assertEquals("user999", response.getFields().get("user_id").get(0));
        assertEquals("50.00", response.getFields().get("amount").get(0));
        assertEquals("non-existent-cache-key", response.getFields().get("tf_cache_key").get(0));
        
        // Verify no TF fields are hydrated (cache miss)
        assertNull(response.getFields().get("tablefacility_1"), 
                  "No TF fields should be hydrated on cache miss");
    }

    /**
     * Helper method to serialize a Map<String, String> to JSON string
     */
    private String serializeMap(Map<String, String> map) {
        try {
            com.fasterxml.jackson.databind.ObjectMapper mapper = new com.fasterxml.jackson.databind.ObjectMapper();
            return mapper.writeValueAsString(map);
        } catch (Exception e) {
            throw new RuntimeException("Failed to serialize map to JSON", e);
        }
    }

    /**
     * Test profile to enable caching for this test
     */
    public static class TestProfile implements io.quarkus.test.junit.QuarkusTestProfile {
        @Override
        public Map<String, String> getConfigOverrides() {
            Map<String, String> config = new HashMap<>();
            config.put("app.caching.enabled", "true");
            config.put("app.caching.tablefacility.ttl", "3600");
            return config;
        }
    }
}
